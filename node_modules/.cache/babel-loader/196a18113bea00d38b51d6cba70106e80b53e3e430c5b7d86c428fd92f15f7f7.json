{"ast":null,"code":"var _jsxFileName = \"/Users/dodricsykes/Coding Projects/Projects/react-projects/note_taking_react/src/NotesList.js\";\nimport React from \"react\";\nimport Note from \"./Note.js\";\n\n// Function purpose: Controls and renders the list of notes (contained in the notes list array)\nconst NotesList = props => {\n  const renderNote = note => /*#__PURE__*/React.createElement(Note, {\n    onType: props.onType // Function is passed to Note component via props and subsquently the Note.js\n    ,\n    key: note.id,\n    note: note,\n    deleteNote: props.deleteNote // Function is passed to Note component via props and subsquently the Note.js\n    ,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 5\n    }\n  });\n\n  // Function purpose (why): I want to sife through my notes array (list of notes) and only access/target ones satisfying my specific condition\n  const keepSearchMatches = note => {\n    return note.doesMatchSearch === true;\n  };\n\n  // Used (note) as parameter in callback function because I want to access each note object in the notes array individually and execute my code for each object individually -> Using the data from the Note component in the Note.js module\n  // Can have another return statement in the code above since its nestled inside a separate function than the return statement further down (nestled inside the oveall NotesList function) -> using the \"return\" keyword allows me to use the value or results of my code outside of the scope in which it sits -> Needed to use \"return\" here because I want the keepSearchMatches function to result or return a specific value\n\n  // Function purpose (why): Using the \"keepSearchMatches\" variable as an arguement/parameter, I want to filter through the notes array and filter out the notes in the notes array NOT meeting the condition stated in the \"keepSearchMatches\" variable (thus forming a new filtered notes array)\n  const searchMatches = props.notes.filter(keepSearchMatches);\n\n  // Using .filter() here allows the code to iterate over each note object in the notes array and filter out the ones whose doesMatchSearch value is false (in this one instance); creating a new array called searchMatches containing only note objects which contain doesMatchSearch property has a true value using \"props.notes\" to target the notes propety of the App component containing the initial array\n\n  const noteElement = searchMatches.map(renderNote);\n  {\n    /* Function purpose (why): Because I now want to use my new filtered array (searchMatches, which contains the notes array data) as a starting point for rendering my sticky notes, I need to use the map method to iterate over each note object inside the notes array/searchMatches, rendering only the ones whose \"doesMatchSearch\" property contains a true value via way of the searchMatches variable  */\n  }\n  return /*#__PURE__*/React.createElement(\"ul\", {\n    className: \"notes-list\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 5\n    }\n  }, noteElement)\n\n  // What the above code is doing: replacing the three list items (*See \"Note.js\" module for old list item code) with three Note JSX elements. The Note JSX elements will replace your static JSX sticky notes.-> The Notes components are replaced by the \"NoteElement\" variable (To pass a note object from the notes array to each Note component you’ll map over props.notes. As you map over this array, call the renderNote function to render a Note component for each object in the notes array that was passed to the NotesList component. Assign the result of mapping over the array to the variable noteElements)\n  // (*See the \"Note.js\" module for copy of unordered list old code) - Move all of the JSX for the unordered list to the NotesList component. Then export the component.\n  ;\n};\n_c = NotesList;\nexport default NotesList;\nvar _c;\n$RefreshReg$(_c, \"NotesList\");","map":{"version":3,"names":["React","Note","NotesList","props","renderNote","note","createElement","onType","key","id","deleteNote","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","keepSearchMatches","doesMatchSearch","searchMatches","notes","filter","noteElement","map","className","_c","$RefreshReg$"],"sources":["/Users/dodricsykes/Coding Projects/Projects/react-projects/note_taking_react/src/NotesList.js"],"sourcesContent":["import React from \"react\";\nimport Note from \"./Note.js\";\n\n// Function purpose: Controls and renders the list of notes (contained in the notes list array)\nconst NotesList = (props) => {\n  const renderNote = (note) => (\n    <Note\n      onType={props.onType} // Function is passed to Note component via props and subsquently the Note.js\n      key={note.id}\n      note={note}\n      deleteNote={props.deleteNote} // Function is passed to Note component via props and subsquently the Note.js\n    />\n  );\n\n  // Function purpose (why): I want to sife through my notes array (list of notes) and only access/target ones satisfying my specific condition\n  const keepSearchMatches = (note) => {\n    return note.doesMatchSearch === true;\n  };\n\n  // Used (note) as parameter in callback function because I want to access each note object in the notes array individually and execute my code for each object individually -> Using the data from the Note component in the Note.js module\n  // Can have another return statement in the code above since its nestled inside a separate function than the return statement further down (nestled inside the oveall NotesList function) -> using the \"return\" keyword allows me to use the value or results of my code outside of the scope in which it sits -> Needed to use \"return\" here because I want the keepSearchMatches function to result or return a specific value\n\n  // Function purpose (why): Using the \"keepSearchMatches\" variable as an arguement/parameter, I want to filter through the notes array and filter out the notes in the notes array NOT meeting the condition stated in the \"keepSearchMatches\" variable (thus forming a new filtered notes array)\n  const searchMatches = props.notes.filter(keepSearchMatches);\n\n  // Using .filter() here allows the code to iterate over each note object in the notes array and filter out the ones whose doesMatchSearch value is false (in this one instance); creating a new array called searchMatches containing only note objects which contain doesMatchSearch property has a true value using \"props.notes\" to target the notes propety of the App component containing the initial array\n\n  const noteElement = searchMatches.map(renderNote);\n\n  {\n    /* Function purpose (why): Because I now want to use my new filtered array (searchMatches, which contains the notes array data) as a starting point for rendering my sticky notes, I need to use the map method to iterate over each note object inside the notes array/searchMatches, rendering only the ones whose \"doesMatchSearch\" property contains a true value via way of the searchMatches variable  */\n  }\n\n  return (\n    <ul className=\"notes-list\">{noteElement}</ul>\n\n    // What the above code is doing: replacing the three list items (*See \"Note.js\" module for old list item code) with three Note JSX elements. The Note JSX elements will replace your static JSX sticky notes.-> The Notes components are replaced by the \"NoteElement\" variable (To pass a note object from the notes array to each Note component you’ll map over props.notes. As you map over this array, call the renderNote function to render a Note component for each object in the notes array that was passed to the NotesList component. Assign the result of mapping over the array to the variable noteElements)\n    // (*See the \"Note.js\" module for copy of unordered list old code) - Move all of the JSX for the unordered list to the NotesList component. Then export the component.\n  );\n};\n\nexport default NotesList;\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,IAAI,MAAM,WAAW;;AAE5B;AACA,MAAMC,SAAS,GAAIC,KAAK,IAAK;EAC3B,MAAMC,UAAU,GAAIC,IAAI,iBACtBL,KAAA,CAAAM,aAAA,CAACL,IAAI;IACHM,MAAM,EAAEJ,KAAK,CAACI,MAAO,CAAC;IAAA;IACtBC,GAAG,EAAEH,IAAI,CAACI,EAAG;IACbJ,IAAI,EAAEA,IAAK;IACXK,UAAU,EAAEP,KAAK,CAACO,UAAW,CAAC;IAAA;IAAAC,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,CAC/B,CACF;;EAED;EACA,MAAMC,iBAAiB,GAAIZ,IAAI,IAAK;IAClC,OAAOA,IAAI,CAACa,eAAe,KAAK,IAAI;EACtC,CAAC;;EAED;EACA;;EAEA;EACA,MAAMC,aAAa,GAAGhB,KAAK,CAACiB,KAAK,CAACC,MAAM,CAACJ,iBAAiB,CAAC;;EAE3D;;EAEA,MAAMK,WAAW,GAAGH,aAAa,CAACI,GAAG,CAACnB,UAAU,CAAC;EAEjD;IACE;EAAA;EAGF,oBACEJ,KAAA,CAAAM,aAAA;IAAIkB,SAAS,EAAC,YAAY;IAAAb,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAAEM,WAAgB;;EAE5C;EACA;EAAA;AAEJ,CAAC;AAACG,EAAA,GAnCIvB,SAAS;AAqCf,eAAeA,SAAS;AAAC,IAAAuB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}